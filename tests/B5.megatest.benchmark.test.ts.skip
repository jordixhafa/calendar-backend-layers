import { createConnection } from 'typeorm';
import { User } from './src/models/User';
import { Event } from './src/models/Event';
import { performance } from 'perf_hooks';
import * as fs from 'fs';
import { mark, measure } from '@oaklean/core';

const USERS = 500;
const EVENTS_PER_USER = 100;
const NOTIFY_RATIO = 0.2; // 20% of events trigger notifications
const DELETE_RATIO = 0.05; // 5% events and users deleted
const DB_LOG = 'benchmark_mega_day.log';

const logEnergyStart = `sudo powermetrics --samplers cpu_power,disk --output ${DB_LOG} &`;
const logEnergyStop = `pkill -f powermetrics`;

async function createUsers(n: number) {
  mark('users:start');
  const users = [];
  for (let i = 0; i < n; i++) {
    const user = User.create({
      name: `User ${i}`,
      email: `user${i}@test.com`,
      password: 'securepass'
    });
    users.push(user);
  }
  await User.save(users);
  mark('users:end');
}

async function createEvents(users: User[]) {
  mark('events:start');
  const events = [];
  const now = new Date();

  for (const user of users) {
    for (let i = 0; i < EVENTS_PER_USER; i++) {
      const start = new Date(now.getTime() + i * 60000);
      const end = new Date(start.getTime() + 3600000);
      events.push(Event.create({
        title: `Event ${i}`,
        description: `Description ${i}`,
        start,
        end,
        label: 'work',
        owner: user,
        recurrence: i % 2 === 0 ? 'daily' : 'none',
        invitees: [],
      }));
    }
  }
  await Event.save(events);
  mark('events:end');
}

async function classifyAndNotify() {
  mark('notify:start');
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);

  const todayEvents = await Event.createQueryBuilder('event')
    .where('event.start >= :start AND event.start < :end', {
      start: today,
      end: tomorrow,
    })
    .getMany();

  const toNotify = todayEvents.slice(0, Math.floor(todayEvents.length * NOTIFY_RATIO));

  for (const e of toNotify) {
    // Simulate notify
    e.invitees = ['notified@test.com'];
    await e.save();
  }
  mark('notify:end');
}

async function modifyAndDelete() {
  mark('modify-delete:start');

  const users = await User.find();
  const events = await Event.find();

  // Modify
  for (let i = 0; i < Math.floor(events.length * 0.1); i++) {
    events[i].label = 'updated';
    await events[i].save();
  }

  // Delete
  for (let i = 0; i < Math.floor(events.length * DELETE_RATIO); i++) {
    await events[i].remove();
  }
  for (let i = 0; i < Math.floor(users.length * DELETE_RATIO); i++) {
    await users[i].remove();
  }
  mark('modify-delete:end');
}

async function benchmarkMegaDay() {
  console.log('Starting benchmark...');
  await createConnection();

  console.log('Launching powermetrics...');
  require('child_process').execSync(logEnergyStart);

  await createUsers(USERS);
  const users = await User.find();

  await createEvents(users);
  await classifyAndNotify();
  await modifyAndDelete();

  require('child_process').execSync(logEnergyStop);

  console.log('Benchmark complete. Measuring...');
  const measurements = measure();

  fs.writeFileSync('oaklean_measurements.json', JSON.stringify(measurements, null, 2));
}

benchmarkMegaDay().catch(console.error);
